library(dplyr)
library(hmmTMB) # R package for fitting hidden markov models
library(ggplot2)
load("/Users/donnie/Desktop/Websites/biodivmonit/data for HMM analysis/Data_hmm.rda")
str(Data_hmm)
head(Data_hmm)
set.seed(10)
#List of best initial parameter values
par3c<- list(Voc = list(mean = c(0,0,0), sd = c(0.3862733, 0.2576610, 0.7226931)))
#Define the hidden state process
hid3c<-MarkovChain$new(data=Data_hmm,n_states = 3)
#Define the observation process
obs3c <- Observation$new(data = Data_hmm,
dists = list(Voc = "norm"),
par = par3c,
n_states = 3)
#To constrain the mean of the gaussian distribution in each state to zero
fixpar3c<-list(obs=c("Voc.mean.state1.(Intercept)"=NA,"Voc.mean.state2.(Intercept)"=NA, "Voc.mean.state3.(Intercept)"=NA))
#Create HMM object using observation and hidden state components
hmm3c<-HMM$new(obs=obs3c,hid=hid3c,fixpar = fixpar3c)
#fitting HMM
hmm3c$fit(silent=F, itnmax= 10000, control = list("maxit"=10000), method="BFGS")
hmm3c$out()
#Extract the viterbi-decoded states
states <- factor(hmm3c$viterbi(), levels = c("2", "1", "3"))
Data_hmm$State <- states
# Define state colors
state_colors <- c("1" = "#FFC107", "2" = "#009E73", "3" = "#FF0000")  # Warning, Normal, Disturbance
typhoon_legend <- data.frame(
Typhoon = factor(c("Trami", "Kong-Rey"), levels = c("Trami", "Kong-Rey")),
Date = as.Date(c("2018-09-29", "2018-10-05"))
)
ggplot(Data_hmm, aes(x = Date, y = Voc)) +
geom_line(color = "black") +
geom_vline(data = typhoon_legend, aes(xintercept = Date, color = Typhoon),
linetype = "dashed", size = 0.6, show.legend = FALSE) +
geom_point(aes(color = State), size = 1) +
scale_color_manual(
name = "States",
values = c(state_colors, "Trami" = "#FD8D3C", "Kong-Rey" = "purple"),
breaks = c("2", "1", "3"),
labels = c("Normal", "Warning", "Disturbed")
) +
scale_x_date(
date_breaks = "5 days",
date_labels = "%d-%b"
) +
labs(
x = "Date",
y = "Log Change in Vocalisations"
) +
theme_minimal() +
theme(
axis.text.x = element_text(size=7, angle = 45, hjust = 0.8),
axis.text.y = element_text(size=7, hjust = 0.8),
legend.title = element_text(size = 9),
legend.text = element_text(size = 7),
axis.title.x = element_text(size=7),
axis.title.y = element_text(size=7),
strip.text = element_text(size = 6),
panel.border = element_rect(color = "black", fill = NA, size = 0.5),
axis.line = element_line(color = "black")
)
#In-sample model selection : 1. Adjusted BIC calculation
## Adjusted BIC for the model
BIC_3c_adj=-2*hmm3c$llk()+11*log(66/(2*pi))
BIC_3c_adj
set.seed(20)
gof<-function(Data_hmm){
s<-c(quantile(Data_hmm$Voc,seq(0,1,by=0.25)),autocor=cor(Data_hmm$Voc[-1],Data_hmm$Voc[-nrow(Data_hmm)],use = "complete.obs"))
}
# Run posterior predictive checks
checks_3c<-hmm3c$check(check_fn = gof, silent = T, nsims = 2000)
# Plot histograms of simulated statistics
checks_3c$plot
# Calculate the median of each simulated statistic
median_simulated_stats <- apply(checks_3c$stats, 1, median)
# Derive the observed statistics of the data
observed_stats <- checks_3c$obs_stat
# Compare observed statistics with median of the simulated statistics
comparison_3c <- data.frame(
Observed = observed_stats,
Median_Simulated = median_simulated_stats
)
# Calculate the absolute difference between observed and median simulated statistics
comparison_3c$Abs_Diff_Median <- abs(comparison_3c$Observed - comparison_3c$Median_Simulated)
comparison_3c
## 3 state mean constraint model with precipitation: 3C_p
par3c_p <- list(Voc = list(mean = c(0,0,0), sd = c(0.4051870, 0.2268517, 0.7426536)))
#Incorporate scaled mean precipitation to the transition probability matrix
hid3c_p<-MarkovChain$new(data=Data_hmm,n_states = 3,formula = ~Precip_z)
obs3c_p <- Observation$new(data = Data_hmm,
dists = list(Voc = "norm"),
par = par3c_p,
n_states = 3)
fixpar3c_p<-list(obs=c("Voc.mean.state1.(Intercept)"=NA,"Voc.mean.state2.(Intercept)"=NA, "Voc.mean.state3.(Intercept)"=NA))
hmm3c_p<-HMM$new(obs=obs3c_p,hid=hid3c_p,fixpar = fixpar3c_p)
hmm3c_p$fit(silent=F, itnmax= 20000, control = list("maxit"=20000), method="BFGS")
hmm3c_p$out()
hmm3c_p$viterbi()
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
###########################################################################################################
rm(list=ls())
library(dplyr)
library(hmmTMB) # R package for fitting hidden markov models
library(ggplot2)
library(readxl)
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
head(nutrition_data)
str(nutrition_data)
summary(nutrition_data)
summary(is.na(nutrition_data))
View(nutrition_data)
set.seed(27011998)
nutrition_data$IDNumber <- as.factor(nutrition_data$IDNumber)
# Load required libraries --------------------------------------------------------
library(dplyr)         # Data manipulation and filtering
library(hmmTMB)        # Main package for fitting hidden Markov models
library(ggplot2)       # Data visualization
library(readxl)        # Reading Excel files
library(tidyr)         # Data tidying
library(magrittr)      # Pipe operators
# Clear workspace to ensure clean environment -----------------------------------
rm(list = ls())
# Read the main nutrition dataset -----------------------------------------------
# This dataset contains nutritional information with food group energy contributions
# Variables 56-73 represent percentage energy contributions from 18 food groups
cat("Loading nutrition dataset...\n")
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
# Display basic information about the dataset ------------------------------------
cat("Dataset dimensions:", dim(nutrition_data), "\n")
cat("Column names:\n")
print(names(nutrition_data))
# View first few rows to understand data structure -------------------------------
cat("First 6 rows of nutrition data:\n")
print(head(nutrition_data))
# Check data structure -----------------------------------------------------------
cat("Data structure:\n")
str(nutrition_data)
# Method 1: If column names are descriptive
food_group_cols <- names(nutrition_data) %>%
grep("FG.*Percentage|Percentage.*FG|Food.*Group", ., value = TRUE, ignore.case = TRUE)
# Method 2: If no clear pattern, use position-based selection (columns 56-73)
if (length(food_group_cols) == 0) {
food_group_cols <- names(nutrition_data)[56:73]
}
cat("Selected food group percentage columns:\n")
print(food_group_cols)
# Extract the food group percentage data ----------------------------------------
food_group_data <- nutrition_data %>%
select(all_of(food_group_cols))
# Display summary statistics for food group percentages -------------------------
cat("Summary statistics for food group percentages:\n")
print(summary(food_group_data))
# Check for missing values -------------------------------------------------------
cat("Missing values per food group:\n")
print(colSums(is.na(food_group_data)))
# Remove rows with missing values in food group variables -----------------------
# hmmTMB requires complete cases for model fitting
complete_data <- nutrition_data %>%
select(all_of(food_group_cols)) %>%
na.omit()
View(complete_data)
cat("Number of complete cases:", nrow(complete_data), "\n")
# Standardize the food group percentages -----------------------------------------
# This helps with model convergence and interpretation
# We'll scale each food group to have mean=0 and sd=1
scaled_food_groups <- scale(complete_data)
# Standardize the food group percentages -----------------------------------------
# This helps with model convergence and interpretation
# We'll scale each food group to have mean=0 and sd=1
scaled_food_groups <- scale(complete_data)
# Convert back to data frame with proper column names
scaled_food_groups <- as.data.frame(scaled_food_groups)
names(scaled_food_groups) <- food_group_cols
# Standardize the food group percentages -----------------------------------------
# This helps with model convergence and interpretation
# We'll scale each food group to have mean=0 and sd=1
scaled_food_groups <- scale(complete_data)
install.packages(c("hmmTMB", "compositions", "dplyr", "tidyr", "ggplot2", "zCompositions"))
install.packages(c("hmmTMB", "compositions", "dplyr", "tidyr", "ggplot2", "zCompositions"))
library(hmmTMB)         # Modeling
library(compositions)   # T-DIET: CoDA geometry
library(zCompositions)  # T-DIET: Zero handling
library(dplyr)          # Data manipulation
library(tidyr)          # Data pivoting
library(ggplot2)        # Plotting
library(ggalluvial)     # Flow diagrams
library(stringr)        # String manipulation
library(RColorBrewer)   # Colorblind palettes
install.packages("compositions")
library(compositions)   # T-DIET: CoDA geometry
theme_bw(base_size = base_size, base_family = base_family) +
theme(
plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0),
plot.subtitle = element_text(size = rel(1), margin = margin(b = 10)),
plot.caption = element_text(size = rel(0.8), color = "grey30"),
panel.grid.minor = element_blank(),
panel.border = element_blank(), # Remove black box around
axis.line = element_line(color = "black"), # Add meaningful axis lines
legend.title = element_text(face = "bold"),
legend.text = element_text(size = rel(0.9)),
strip.background = element_rect(fill = "white", color = NA), # Clean headers
strip.text = element_text(face = "bold", size = rel(1))
)
# Colorblind friendly palette (Okabe-Ito adaptation)
cb_palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")
# Mapping FG1-FG18 based on Nutritics Document
fg_dictionary <- c(
"FG1" = "Grains, Rice & Pasta", "FG2" = "Bread & Rolls",
"FG3" = "Breakfast Cereals", "FG4" = "Biscuits & Cakes",
"FG5" = "Milk & Yogurt", "FG6" = "Creams & Ice-cream",
"FG7" = "Cheeses", "FG8" = "Butter & Fats",
"FG9" = "Eggs", "FG10" = "Potatoes",
"FG11" = "Vegetables", "FG12" = "Fruit",
"FG13" = "Fish", "FG14" = "Meat",
"FG15" = "Beverages", "FG16" = "Sugars",
"FG17" = "Soups & Sauces", "FG18" = "Supplements"
)
# Parse data
data <- read_excel("sampled_data_nutrition.xlsx")
library(ggplot2)
library(readxl)
# ------------------------------------------------------------------------------
# GRAPHICS THEME: "Publication Ready"
# Adhering to the checklist: Serif font, large text, no clutter, colorblind friendly
# ------------------------------------------------------------------------------
theme_publication <- function(base_size = 14, base_family = "serif") {
theme_bw(base_size = base_size, base_family = base_family) +
theme(
plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0),
plot.subtitle = element_text(size = rel(1), margin = margin(b = 10)),
plot.caption = element_text(size = rel(0.8), color = "grey30"),
panel.grid.minor = element_blank(),
panel.border = element_blank(), # Remove black box around
axis.line = element_line(color = "black"), # Add meaningful axis lines
legend.title = element_text(face = "bold"),
legend.text = element_text(size = rel(0.9)),
strip.background = element_rect(fill = "white", color = NA), # Clean headers
strip.text = element_text(face = "bold", size = rel(1))
)
}
# Colorblind friendly palette (Okabe-Ito adaptation)
cb_palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")
# Mapping FG1-FG18 based on Nutritics Document
fg_dictionary <- c(
"FG1" = "Grains, Rice & Pasta", "FG2" = "Bread & Rolls",
"FG3" = "Breakfast Cereals", "FG4" = "Biscuits & Cakes",
"FG5" = "Milk & Yogurt", "FG6" = "Creams & Ice-cream",
"FG7" = "Cheeses", "FG8" = "Butter & Fats",
"FG9" = "Eggs", "FG10" = "Potatoes",
"FG11" = "Vegetables", "FG12" = "Fruit",
"FG13" = "Fish", "FG14" = "Meat",
"FG15" = "Beverages", "FG16" = "Sugars",
"FG17" = "Soups & Sauces", "FG18" = "Supplements"
)
# Parse data
data <- read_excel("sampled_data_nutrition.xlsx")
# 2. DATA CLEANING
# ----------------
# Remove rows that are entirely empty (due to text dump artifacts) or missing key data
clean_data <- data %>%
filter(!is.na(IDNumber), !is.na(Visit)) %>%
mutate(
IDNumber = as.factor(IDNumber),
Visit = as.factor(Visit)
)
# Extract Compositional Columns (The 18 Food Groups percentages)
comp_cols <- paste0("FG", 1:18, "_perc_ener_contr_18")
# Ensure all compositional columns are numeric (sometimes import issues cause factors)
clean_data[comp_cols] <- lapply(clean_data[comp_cols], function(x) as.numeric(as.character(x)))
# Filter out rows where compositional data is missing (e.g., the NA rows in input)
clean_data <- clean_data %>%
filter(complete.cases(.[comp_cols]))
# Matrix of compositions
comp_matrix <- as.matrix(clean_data[, comp_cols])
# Force closure (sum to 1)
comp_matrix <- prop.table(comp_matrix, 1)
# Handle zeros (Bayesian-Multiplicative replacement)
# Fallback to epsilon if sparse data causes error
comp_clean <- tryCatch({
zCompositions::cmultRepl(comp_matrix, output = "p-counts", suppress.print = TRUE)
}, error = function(e) {
message("cmultRepl failed (sparse data), using epsilon replacement.")
comp_matrix + 1e-6
})
# Re-close after zero handling
comp_clean <- prop.table(comp_clean, 1)
library(hmmTMB)         # Modeling
library(compositions)   # T-DIET: CoDA geometry
library(zCompositions)  # T-DIET: Zero handling
library(dplyr)          # Data manipulation
library(tidyr)          # Data pivoting
library(ggplot2)        # Plotting
library(ggalluvial)     # Flow diagrams
library(stringr)        # String manipulation
library(RColorBrewer)   # Colorblind palettes
library(ggplot2)
library(readxl)
# ---------------
theme_bw(base_size = base_size, base_family = base_family) +
theme(
plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0),
plot.subtitle = element_text(size = rel(1), margin = margin(b = 10)),
plot.caption = element_text(size = rel(0.8), color = "grey30"),
panel.grid.minor = element_blank(),
panel.border = element_blank(), # Remove black box around
axis.line = element_line(color = "black"), # Add meaningful axis lines
legend.title = element_text(face = "bold"),
legend.text = element_text(size = rel(0.9)),
strip.background = element_rect(fill = "white", color = NA), # Clean headers
strip.text = element_text(face = "bold", size = rel(1))
)
theme_bw(base_size = base_size, base_family = base_family) +
theme(
plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0),
plot.subtitle = element_text(size = rel(1), margin = margin(b = 10)),
plot.caption = element_text(size = rel(0.8), color = "grey30"),
panel.grid.minor = element_blank(),
panel.border = element_blank(), # Remove black box around
axis.line = element_line(color = "black"), # Add meaningful axis lines
legend.title = element_text(face = "bold"),
legend.text = element_text(size = rel(0.9)),
strip.background = element_rect(fill = "white", color = NA), # Clean headers
strip.text = element_text(face = "bold", size = rel(1))
)
library(readxl)
# ------------------------------------------------------------------------------
# GRAPHICS THEME: "Publication Ready"
# Adhering to the checklist: Serif font, large text, no clutter, colorblind friendly
# ------------------------------------------------------------------------------
theme_publication <- function(base_size = 14, base_family = "serif") {
theme_bw(base_size = base_size, base_family = base_family) +
theme(
plot.title = element_text(face = "bold", size = rel(1.2), hjust = 0),
plot.subtitle = element_text(size = rel(1), margin = margin(b = 10)),
plot.caption = element_text(size = rel(0.8), color = "grey30"),
panel.grid.minor = element_blank(),
panel.border = element_blank(), # Remove black box around
axis.line = element_line(color = "black"), # Add meaningful axis lines
legend.title = element_text(face = "bold"),
legend.text = element_text(size = rel(0.9)),
strip.background = element_rect(fill = "white", color = NA), # Clean headers
strip.text = element_text(face = "bold", size = rel(1))
)
}
# Colorblind friendly palette (Okabe-Ito adaptation)
cb_palette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")
# Mapping FG1-FG18 based on Nutritics Document
fg_dictionary <- c(
"FG1" = "Grains, Rice & Pasta", "FG2" = "Bread & Rolls",
"FG3" = "Breakfast Cereals", "FG4" = "Biscuits & Cakes",
"FG5" = "Milk & Yogurt", "FG6" = "Creams & Ice-cream",
"FG7" = "Cheeses", "FG8" = "Butter & Fats",
"FG9" = "Eggs", "FG10" = "Potatoes",
"FG11" = "Vegetables", "FG12" = "Fruit",
"FG13" = "Fish", "FG14" = "Meat",
"FG15" = "Beverages", "FG16" = "Sugars",
"FG17" = "Soups & Sauces", "FG18" = "Supplements"
)
# Parse data
data <- read_excel("sampled_data_nutrition.xlsx")
# 2. DATA CLEANING
# ----------------
# Remove rows that are entirely empty (due to text dump artifacts) or missing key data
clean_data <- data %>%
filter(!is.na(IDNumber), !is.na(Visit)) %>%
mutate(
IDNumber = as.factor(IDNumber),
Visit = as.factor(Visit)
)
# Extract Compositional Columns (The 18 Food Groups percentages)
comp_cols <- paste0("FG", 1:18, "_perc_ener_contr_18")
# Ensure all compositional columns are numeric (sometimes import issues cause factors)
clean_data[comp_cols] <- lapply(clean_data[comp_cols], function(x) as.numeric(as.character(x)))
# Filter out rows where compositional data is missing (e.g., the NA rows in input)
clean_data <- clean_data %>%
filter(complete.cases(.[comp_cols]))
# Matrix of compositions
comp_matrix <- as.matrix(clean_data[, comp_cols])
# Force closure (sum to 1)
comp_matrix <- prop.table(comp_matrix, 1)
# Handle zeros (Bayesian-Multiplicative replacement)
# Fallback to epsilon if sparse data causes error
comp_clean <- tryCatch({
zCompositions::cmultRepl(comp_matrix, output = "p-counts", suppress.print = TRUE)
}, error = function(e) {
message("cmultRepl failed (sparse data), using epsilon replacement.")
comp_matrix + 1e-6
})
# Re-close after zero handling
comp_clean <- prop.table(comp_clean, 1)
data("energy", package = "MSwM")
library(hmmTMB)         # Modeling
library(compositions)   # T-DIET: CoDA geometry
library(zCompositions)  # T-DIET: Zero handling
library(dplyr)          # Data manipulation
library(hmmTMB)         # Modeling
library(compositions)   # T-DIET: CoDA geometry
library(zCompositions)  # T-DIET: Zero handling
library(dplyr)          # Data manipulation
library(tidyr)          # Data pivoting
library(ggplot2)        # Plotting
library(ggalluvial)     # Flow diagrams
library(stringr)        # String manipulation
library(RColorBrewer)   # Colorblind palettes
library(ggplot2)
library(readxl)
data("energy", package = "MSwM")
hid <- MarkovChain$new(data = energy, n_states = 2)
hid
dists <- list(Price = "norm")
par0 <- list(Price = list(mean = c(3, 6), sd = c(1, 1)))
f <- list(Price = list(mean = ~ s(EurDol, k = 10, bs = "cs"),
+ sd = ~ poly(EurDol, 3)))
f <- list(Price = list(mean = ~ s(EurDol, k = 10, bs = "cs"),
+ sd = ~ poly(EurDol, 3)))
data("energy", package = "MSwM")
hid <- MarkovChain$new(data = energy, n_states = 2)
dists <- list(Price = "norm")
par0 <- list(Price = list(mean = c(3, 6), sd = c(1, 1)))
f <- list(Price = list(mean = ~ s(EurDol, k = 10, bs = "cs"),
+ sd = ~ poly(EurDol, 3)))
f <- list(
Price = list(
mean = ~ s(EurDol, k = 10, bs = 'cs'),
sd   = ~ poly(EurDol, 3)
)
)
obs <- Observation$new(data = energy, n_states = 2, dists = dists,
+ par = par0, formulas = f)
obs <- Observation$new(
data      = energy,
n_states  = 2,
dists     = dists,
par       = par0,
formulas  = f
)
hmm <- HMM$new(hid = hid, obs = obs)
hmm$fit(silent = TRUE)
R> energy$viterbi <- factor(paste0("State ", hmm$viterbi()))
energy$viterbi <- factor(paste0("State ", hmm$viterbi()))
hmm$plot(what = "obspar", var = "EurDol", i = "Price.mean") +
+ geom_point(aes(x = EurDol, y = Price, fill = viterbi, col = viterbi),
+ data = energy, alpha = 0.3) +
energy$viterbi <- factor(paste0("State ", hmm$viterbi()))
hmm$plot(what = "obspar", var = "EurDol", i = "Price.mean") +
geom_point(
aes(x = EurDol, y = Price, fill = viterbi, col = viterbi),
data = energy, alpha = 0.3
) +
theme(legend.position = "none")
hmm$plot(what = "obspar", var = "EurDol", i = "Price.sd") +
theme(legend.position.inside = c(0.3, 0.7))
EurDol <- seq(0.65, 1.15, by = 0.1)
newdata <- data.frame(EurDol = EurDol)
par <- hmm$predict(what = "obspar", newdata = newdata)
w <- table(hmm$viterbi())/nrow(energy)
grid <- seq(min(energy$Price), max(energy$Price), length = 100)
pdf_ls <- lapply(1:dim(par)[3], function(i) {
p <- par[,,i]  # extract the i-th matrix slice of 'par'
# Calculate PDFs for each state
pdf1 <- w[1] * dnorm(grid, mean = p["Price.mean", "state 1"],
sd = p["Price.sd", "state 1"])
pdf2 <- w[2] * dnorm(grid, mean = p["Price.mean", "state 2"],
sd = p["Price.sd", "state 2"])
# Combine into a data frame
res <- data.frame(
price = grid,
pdf = c(pdf1, pdf2),
state = factor(rep(1:2, each = length(grid))),
eurdol = paste0("EurDol = ", EurDol[i])
)
return(res)
})
pdf_df <- do.call(rbind, pdf_ls)
ggplot(pdf_df, aes(price, pdf)) +
+ facet_wrap("eurdol") +
+ geom_histogram(aes(x = Price, y=..density..), bins = 20,
+ col = "white", bg = "lightgrey", data = energy) +
ggplot(pdf_df, aes(x = price, y = pdf, color = state)) +
geom_line() +
facet_wrap(~eurdol)
ggplot(pdf_df, aes(x = price, y = pdf)) +
facet_wrap(~eurdol) +
geom_histogram(
aes(x = Price, y = ..density..),
bins = 20,
col = "white",
fill = "lightgrey",
data = energy
) +
geom_line(aes(col = state), size = 1) +
theme_bw() +
labs(x = "Price", y = NULL) +
scale_color_manual(values = hmmTMB:::hmmTMB_cols)
rm(list=ls())
library(dplyr)
library(hmmTMB) # R package for fitting hidden markov models
library(ggplot2)
library(readxl)
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
head(nutrition_data)
str(nutrition_data)
View(nutrition_data)
