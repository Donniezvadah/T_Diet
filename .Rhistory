}
cat("Selected food group percentage columns:\n")
print(food_group_cols)
cat("Selected food group percentage columns:\n")
print(food_group_cols)
# Extract the food group percentage data ----------------------------------------
food_group_data <- nutrition_data %>%
select(all_of(food_group_cols))
# Display summary statistics for food group percentages -------------------------
cat("Summary statistics for food group percentages:\n")
print(summary(food_group_data))
View(food_group_data)
food_group_data[colSums()]
names(food_group_data)
# Load required libraries --------------------------------------------------------
library(dplyr)         # Data manipulation and filtering
library(hmmTMB)        # Main package for fitting hidden Markov models
library(ggplot2)       # Data visualization
library(readxl)        # Reading Excel files
library(tidyr)         # Data tidying
library(magrittr)      # Pipe operators
# Clear workspace to ensure clean environment -----------------------------------
rm(list = ls())
# Read the main nutrition dataset -----------------------------------------------
# This dataset contains nutritional information with food group energy contributions
# Variables 56-73 represent percentage energy contributions from 18 food groups
cat("Loading nutrition dataset...\n")
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
# Display basic information about the dataset ------------------------------------
cat("Dataset dimensions:", dim(nutrition_data), "\n")
cat("Column names:\n")
print(names(nutrition_data))
# View first few rows to understand data structure -------------------------------
cat("First 6 rows of nutrition data:\n")
print(head(nutrition_data))
# Check data structure -----------------------------------------------------------
cat("Data structure:\n")
str(nutrition_data)
# Method 1: If column names are descriptive
food_group_cols <- names(nutrition_data) %>%
grep("FG.*Percentage|Percentage.*FG|Food.*Group", ., value = TRUE, ignore.case = TRUE)
# Method 2: If no clear pattern, use position-based selection (columns 56-73)
if (length(food_group_cols) == 0) {
food_group_cols <- names(nutrition_data)[56:73]
}
cat("Selected food group percentage columns:\n")
print(food_group_cols)
# Extract the food group percentage data ----------------------------------------
food_group_data <- nutrition_data %>%
select(all_of(food_group_cols))
# Display summary statistics for food group percentages -------------------------
cat("Summary statistics for food group percentages:\n")
print(summary(food_group_data))
# Check for missing values -------------------------------------------------------
cat("Missing values per food group:\n")
print(colSums(is.na(food_group_data)))
# First, let's examine the actual column names to identify ID and time variables
cat("All column names in dataset:\n")
print(names(nutrition_data))
# Look for potential ID columns (subject/participant identifiers)
id_patterns <- c("ID", "id", "subject", "participant", "person", "user", "respondent")
id_col <- NULL
for (pattern in id_patterns) {
matches <- grep(pattern, names(nutrition_data), ignore.case = TRUE, value = TRUE)
if (length(matches) > 0) {
id_col <- matches[1]  # Take first match
cat("Found ID column:", id_col, "\n")
break
}
}
# Look for potential time/visit columns
time_patterns <- c("time", "visit", "date", "day", "week", "month", "occasion", "measurement")
time_col <- NULL
for (pattern in time_patterns) {
matches <- grep(pattern, names(nutrition_data), ignore.case = TRUE, value = TRUE)
if (length(matches) > 0) {
time_col <- matches[1]  # Take first match
cat("Found time column:", time_col, "\n")
break
}
}
# If no ID column found, create a simple row identifier
if (is.null(id_col)) {
nutrition_data$subject_id <- seq_len(nrow(nutrition_data))
id_col <- "subject_id"
cat("Created subject_id column as row identifier\n")
}
# If no time column found, create a simple visit number
if (is.null(time_col)) {
nutrition_data$visit_number <- seq_len(nrow(nutrition_data))
time_col <- "visit_number"
cat("Created visit_number column as time indicator\n")
}
# Extract the food group percentage variables (columns 56-73) --------------------
# Method 1: If column names are descriptive
food_group_cols <- names(nutrition_data) %>%
grep("FG.*Percentage|Percentage.*FG|Food.*Group|Energy.*Contribution", ., value = TRUE, ignore.case = TRUE)
# Extract the food group percentage variables (columns 56-73) --------------------
# Method 1: If column names are descriptive
food_group_cols <- names(nutrition_data) %>%
grep("FG.*Percentage|Percentage.*FG|Food.*Group|Energy.*Contribution", ., value = TRUE, ignore.case = TRUE)
# Method 2: If no clear pattern, use position-based selection (columns 56-73)
if (length(food_group_cols) == 0) {
if (ncol(nutrition_data) >= 73) {
food_group_cols <- names(nutrition_data)[56:73]
} else {
# Use last 18 columns as food groups if dataset has fewer columns
food_group_cols <- tail(names(nutrition_data), 18)
}
}
cat("Selected food group percentage columns:\n")
print(food_group_cols)
# Create dataset with ID, time, and food group variables ------------------------
hmm_data <- nutrition_data %>%
select(all_of(c(id_col, time_col, food_group_cols)))
cat("HMM dataset dimensions:", dim(hmm_data), "\n")
cat("HMM dataset columns:\n")
print(names(hmm_data))
# Check for missing values in key variables -----------------------------------
cat("Missing values summary:\n")
cat("ID column missing:", sum(is.na(hmm_data[[id_col]])), "\n")
cat("Time column missing:", sum(is.na(hmm_data[[time_col]])), "\n")
cat("Food group columns missing:\n")
food_group_missing <- colSums(is.na(hmm_data[, food_group_cols]))
print(food_group_missing)
# Load required libraries with tidyverse for data manipulation and visualization
library(tidyverse)    # Includes dplyr, tidyr, ggplot2, etc.
library(hmmTMB)       # For fitting hidden Markov models
library(readxl)       # For reading Excel files
# Load required libraries with tidyverse for data manipulation and visualization
library(tidyverse)    # Includes dplyr, tidyr, ggplot2, etc.
library(hmmTMB)       # For fitting hidden Markov models
library(readxl)       # For reading Excel files
# Clear workspace
rm(list = ls())
# Load and inspect the dataset
cat("Loading and preparing nutrition data...\n")
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
# Display dataset information
cat("\n=== Dataset Information ===\n")
cat("Dimensions:", nrow(nutrition_data), "rows x", ncol(nutrition_data), "columns\n")
cat("\nFirst 3 rows:\n")
print(utils::head(nutrition_data, 3))
# Helper function to find columns by pattern
find_columns <- function(patterns, data = nutrition_data) {
matches <- lapply(patterns, function(p) {
grep(p, names(data), ignore.case = TRUE, value = TRUE)
})
unlist(Filter(length, matches))
}
# Load required libraries with tidyverse for data manipulation and visualization
library(tidyverse)    # Includes dplyr, tidyr, ggplot2, etc.
library(hmmTMB)       # For fitting hidden Markov models
library(readxl)       # For reading Excel files
# Clear workspace
rm(list = ls())
# Load and inspect the dataset
cat("Loading and preparing nutrition data...\n")
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
# Display dataset information
cat("\n=== Dataset Information ===\n")
cat("Dimensions:", nrow(nutrition_data), "rows x", ncol(nutrition_data), "columns\n")
cat("\nFirst 3 rows:\n")
print(utils::head(nutrition_data, 3))
# Helper function to find columns by pattern
find_columns <- function(patterns, data = nutrition_data) {
matches <- lapply(patterns, function(p) {
grep(p, names(data), ignore.case = TRUE, value = TRUE)
})
unlist(Filter(length, matches))
}
# Set ID and Visit columns directly
id_col <- "IDNumber"
time_col <- "Visit"
# Create IDNumber and Visit columns if they don't exist
if (!id_col %in% names(nutrition_data)) {
nutrition_data[[id_col]] <- seq_len(nrow(nutrition_data))
cat("Created", id_col, "column as row identifier\n")
}
if (!time_col %in% names(nutrition_data)) {
nutrition_data[[time_col]] <- seq_len(nrow(nutrition_data))
cat("Created", time_col, "column as time indicator\n")
}
# Identify food group columns (variables 56-73 or by pattern)
food_group_cols <- find_columns(c("FG.*Percentage", "Percentage.*FG", "Food.*Group", "Energy.*Contribution"))
# Fallback to position-based selection if no columns found by pattern
if (length(food_group_cols) == 0) {
food_group_cols <- if (ncol(nutrition_data) >= 73) {
names(nutrition_data)[56:73]
} else {
tail(names(nutrition_data), 18)
}
}
# Create final dataset with complete cases only
hmm_data <- nutrition_data %>%
select(all_of(c(id_col, time_col, food_group_cols))) %>%
filter(complete.cases(.))
# Convert food group columns to numeric and scale
hmm_data <- hmm_data %>%
mutate(across(all_of(food_group_cols), ~ as.numeric(as.character(.)))) %>%
filter(complete.cases(.)) %>%
mutate(across(all_of(food_group_cols), ~ scale(.)[,1]))
# Display final dataset information
cat("\n=== Processed Dataset ===\n")
cat("Final dimensions:", nrow(hmm_data), "rows x", ncol(hmm_data), "columns\n")
cat("\nSelected columns:", paste(names(hmm_data), collapse = ", "), "\n")
# Summary of food group data
cat("\n=== Food Group Summary ===\n")
print(summary(hmm_data[food_group_cols]))
View(hmm_data)
# Load required libraries with tidyverse for data manipulation and visualization
library(tidyverse)    # Includes dplyr, tidyr, ggplot2, etc.
library(hmmTMB)       # For fitting hidden Markov models
library(readxl)       # For reading Excel files
# Clear workspace
rm(list = ls())
# Load and inspect the dataset
cat("Loading and preparing nutrition data...\n")
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
# Display dataset information
cat("\n=== Dataset Information ===\n")
cat("Dimensions:", nrow(nutrition_data), "rows x", ncol(nutrition_data), "columns\n")
cat("\nFirst 3 rows:\n")
print(utils::head(nutrition_data, 3))
# Helper function to find columns by pattern
find_columns <- function(patterns, data = nutrition_data) {
matches <- lapply(patterns, function(p) {
grep(p, names(data), ignore.case = TRUE, value = TRUE)
})
unlist(Filter(length, matches))
}
# Set ID and Visit columns directly
id_col <- "IDNumber"
time_col <- "Visit"
# Create IDNumber and Visit columns if they don't exist
if (!id_col %in% names(nutrition_data)) {
nutrition_data[[id_col]] <- seq_len(nrow(nutrition_data))
cat("Created", id_col, "column as row identifier\n")
}
if (!time_col %in% names(nutrition_data)) {
nutrition_data[[time_col]] <- seq_len(nrow(nutrition_data))
cat("Created", time_col, "column as time indicator\n")
}
# Identify food group columns (variables 56-73 or by pattern)
food_group_cols <- find_columns(c("FG.*Percentage", "Percentage.*FG", "Food.*Group", "Energy.*Contribution"))
# Fallback to position-based selection if no columns found by pattern
if (length(food_group_cols) == 0) {
food_group_cols <- if (ncol(nutrition_data) >= 73) {
names(nutrition_data)[56:73]
} else {
tail(names(nutrition_data), 18)
}
}
# Create final dataset with complete cases only
clean_data <- nutrition_data %>%
select(all_of(c(id_col, time_col, food_group_cols))) %>%
filter(complete.cases(.))
View(clean_data)
# Load required libraries with tidyverse for data manipulation and visualization
library(tidyverse)    # Includes dplyr, tidyr, ggplot2, etc.
library(hmmTMB)       # For fitting hidden Markov models
library(readxl)       # For reading Excel files
library(ggplot2) # For nice plots
library(rlang) # For variable selection
# Clear workspace
rm(list = ls())
# Load and inspect the dataset
cat("Loading and preparing nutrition data...\n")
nutrition_data <- read_excel("sampled_data_nutrition.xlsx")
# Display dataset information
cat("\n=== Dataset Information ===\n")
cat("Dimensions:", nrow(nutrition_data), "rows x", ncol(nutrition_data), "columns\n")
cat("\nFirst 3 rows:\n")
print(utils::head(nutrition_data, 3))
# Helper function to find columns by pattern
find_columns <- function(patterns, data = nutrition_data) {
matches <- lapply(patterns, function(p) {
grep(p, names(data), ignore.case = TRUE, value = TRUE)
})
unlist(Filter(length, matches))
}
# Set ID and Visit columns directly
id_col <- "IDNumber"
time_col <- "Visit"
# Create IDNumber and Visit columns if they don't exist
if (!id_col %in% names(nutrition_data)) {
nutrition_data[[id_col]] <- seq_len(nrow(nutrition_data))
cat("Created", id_col, "column as row identifier\n")
}
if (!time_col %in% names(nutrition_data)) {
nutrition_data[[time_col]] <- seq_len(nrow(nutrition_data))
cat("Created", time_col, "column as time indicator\n")
}
# Identify food group columns (variables 56-73 or by pattern)
food_group_cols <- find_columns(c("FG.*Percentage", "Percentage.*FG", "Food.*Group", "Energy.*Contribution"))
# Fallback to position-based selection if no columns found by pattern
if (length(food_group_cols) == 0) {
food_group_cols <- if (ncol(nutrition_data) >= 73) {
names(nutrition_data)[56:73]
} else {
tail(names(nutrition_data), 18)
}
}
# Create final dataset with complete cases only
clean_data <- nutrition_data %>%
select(all_of(c(id_col, time_col, food_group_cols))) %>%
filter(complete.cases(.))
food_long <- clean_data %>%
dplyr::select(all_of(c(id_col, time_col, food_group_cols))) %>%
tidyr::pivot_longer(
cols = all_of(food_group_cols),
names_to = "food_group",
values_to = "value"
)
food_long$time_factor <- as.factor(food_long[[time_col]])
food_long$id_factor <- as.factor(food_long[[id_col]])
cat("\n=== Detailed summary statistics by food group (overall) ===\n")
summary_overall <- food_long %>%
dplyr::group_by(food_group) %>%
dplyr::summarise(
n = dplyr::n(),
mean = mean(value, na.rm = TRUE),
sd = sd(value, na.rm = TRUE),
median = median(value, na.rm = TRUE),
p25 = stats::quantile(value, 0.25, na.rm = TRUE),
p75 = stats::quantile(value, 0.75, na.rm = TRUE),
min = min(value, na.rm = TRUE),
max = max(value, na.rm = TRUE),
prop_zero = mean(value == 0, na.rm = TRUE),
prop_missing = mean(is.na(value))
)
cat("\n=== Detailed summary statistics by food group and time ===\n")
summary_by_time <- food_long %>%
dplyr::group_by(food_group, time_factor) %>%
dplyr::summarise(
n = dplyr::n(),
mean = mean(value, na.rm = TRUE),
sd = sd(value, na.rm = TRUE),
median = median(value, na.rm = TRUE),
p25 = stats::quantile(value, 0.25, na.rm = TRUE),
p75 = stats::quantile(value, 0.75, na.rm = TRUE),
min = min(value, na.rm = TRUE),
max = max(value, na.rm = TRUE),
prop_zero = mean(value == 0, na.rm = TRUE),
prop_missing = mean(is.na(value))
)
print(summary_by_time, n = nrow(summary_by_time))
cat("\n=== Visualisations: distributions of food groups ===\n")
plot_density <- ggplot2::ggplot(food_long, ggplot2::aes(x = value)) +
ggplot2::geom_histogram(bins = 30, fill = "steelblue", color = "white") +
ggplot2::facet_wrap(~food_group, scales = "free") +
ggplot2::labs(x = "Value", y = "Count")
print(plot_density)
plot_box_time <- ggplot2::ggplot(food_long, ggplot2::aes(x = time_factor, y = value)) +
ggplot2::geom_boxplot(outlier.alpha = 0.3) +
ggplot2::facet_wrap(~food_group, scales = "free_y") +
ggplot2::labs(x = time_col, y = "Value")
print(plot_box_time)
cat("\n=== Visualisations: longitudinal trajectories by food group ===\n")
plot_trajectories <- ggplot2::ggplot(
food_long,
ggplot2::aes(x = time_factor, y = value, group = id_factor)
) +
ggplot2::geom_line(alpha = 0.2) +
ggplot2::facet_wrap(~food_group, scales = "free_y") +
ggplot2::labs(x = time_col, y = "Value")
print(plot_trajectories)
cat("\n=== Correlation structure between food groups ===\n")
food_cor <- stats::cor(clean_data[food_group_cols], use = "pairwise.complete.obs")
food_cor_df <- as.data.frame(as.table(food_cor))
names(food_cor_df) <- c("var1", "var2", "correlation")
plot_cor <- ggplot2::ggplot(food_cor_df, ggplot2::aes(x = var1, y = var2, fill = correlation)) +
ggplot2::geom_tile() +
ggplot2::scale_fill_distiller(palette = "RdBu", direction = -1) +
ggplot2::coord_equal() +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
ggplot2::labs(x = NULL, y = NULL)
print(plot_cor)
# Matrix of food group variables
food_matrix <- as.matrix(clean_data[food_group_cols])
# PCA ------------------------------------------------------------------------
pca_res <- prcomp(food_matrix, center = TRUE, scale. = TRUE)
cat("\n=== PCA summary ===\n")
print(summary(pca_res))
# Add first two principal components to data
clean_data <- clean_data %>%
mutate(
PC1 = pca_res$x[, 1],
PC2 = pca_res$x[, 2]
)
# Factor analysis ------------------------------------------------------------
fa_res <- factanal(x = food_matrix, factors = 2, scores = "regression")
cat("\n=== Factor analysis loadings ===\n")
print(fa_res$loadings)
fa_scores <- as.data.frame(fa_res$scores)
names(fa_scores) <- paste0("FA", seq_len(ncol(fa_scores)))
clean_data <- bind_cols(clean_data, fa_scores)
# K-means clustering ---------------------------------------------------------
set.seed(123)
kmeans_res <- kmeans(scale(food_matrix), centers = 3, nstart = 25)
clean_data$cluster_k3 <- factor(kmeans_res$cluster)
cat("\n=== Cluster sizes (k = 3) ===\n")
print(table(clean_data$cluster_k3))
cat("\n=== PCA: variance explained and scree data ===\n")
pca_var <- pca_res$sdev^2
pca_var_exp <- pca_var/sum(pca_var)
pca_scree <- data.frame(
PC = seq_along(pca_var),
variance_explained = pca_var_exp,
cumulative_variance = cumsum(pca_var_exp)
)
print(pca_scree)
plot_scree <- ggplot2::ggplot(
pca_scree,
ggplot2::aes(x = PC, y = variance_explained)
) +
ggplot2::geom_col(fill = "steelblue") +
ggplot2::geom_line(ggplot2::aes(y = cumulative_variance), color = "red") +
ggplot2::geom_point(ggplot2::aes(y = cumulative_variance), color = "red") +
ggplot2::scale_x_continuous(breaks = pca_scree$PC) +
ggplot2::labs(y = "Proportion of variance", x = "Principal component")
print(plot_scree)
cat("\n=== PCA: loadings for first components ===\n")
pca_loadings <- as.data.frame(pca_res$rotation[, 1:2])
pca_loadings$variable <- rownames(pca_res$rotation)
print(pca_loadings)
pca_loadings_long <- tidyr::pivot_longer(
pca_loadings,
cols = c("PC1", "PC2"),
names_to = "component",
values_to = "loading"
)
plot_loadings <- ggplot2::ggplot(
pca_loadings_long,
ggplot2::aes(x = variable, y = loading, fill = component)
) +
ggplot2::geom_col(position = "dodge") +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
ggplot2::labs(x = "Food group", y = "Loading")
print(plot_loadings)
cat("\n=== PCA: individual scores on first two components ===\n")
clean_data$time_factor <- as.factor(clean_data[[time_col]])
plot_pca_time <- ggplot2::ggplot(
clean_data,
ggplot2::aes(x = PC1, y = PC2, color = time_factor)
) +
ggplot2::geom_point(alpha = 0.7) +
ggplot2::labs(color = time_col)
print(plot_pca_time)
plot_pca_cluster <- ggplot2::ggplot(
clean_data,
ggplot2::aes(x = PC1, y = PC2, color = cluster_k3)
) +
ggplot2::geom_point(alpha = 0.7) +
ggplot2::labs(color = "Cluster (k = 3)")
print(plot_pca_cluster)
cat("\n=== Factor analysis: loadings table and heatmap ===\n")
fa_loadings <- as.matrix(fa_res$loadings)
fa_loadings_df <- as.data.frame(fa_loadings)
fa_loadings_df$variable <- rownames(fa_loadings)
print(fa_loadings_df)
fa_loadings_long <- tidyr::pivot_longer(
fa_loadings_df,
cols = -variable,
names_to = "factor",
values_to = "loading"
)
plot_fa_loadings <- ggplot2::ggplot(
fa_loadings_long,
ggplot2::aes(x = variable, y = factor, fill = loading)
) +
ggplot2::geom_tile() +
ggplot2::scale_fill_distiller(palette = "RdBu", direction = -1) +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
ggplot2::labs(x = "Food group", y = "Factor")
print(plot_fa_loadings)
cat("\n=== Factor analysis: individual scores on first two factors ===\n")
if (ncol(fa_scores) >= 2) {
plot_fa_scores <- ggplot2::ggplot(
clean_data,
ggplot2::aes(x = FA1, y = FA2, color = time_factor)
) +
ggplot2::geom_point(alpha = 0.7) +
ggplot2::labs(color = time_col)
print(plot_fa_scores)
}
cat("\n=== K-means: cluster centers (in scaled space) ===\n")
cluster_centers <- as.data.frame(kmeans_res$centers)
cluster_centers$cluster <- factor(seq_len(nrow(cluster_centers)))
cluster_centers_long <- tidyr::pivot_longer(
cluster_centers,
cols = -cluster,
names_to = "variable",
values_to = "center"
)
print(cluster_centers_long, n = nrow(cluster_centers_long))
plot_cluster_centers <- ggplot2::ggplot(
cluster_centers_long,
ggplot2::aes(x = variable, y = center, color = cluster, group = cluster)
) +
ggplot2::geom_line() +
ggplot2::geom_point() +
ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1)) +
ggplot2::labs(x = "Food group (scaled)", y = "Cluster center")
print(plot_cluster_centers)
# Inspect final data with model outputs --------------------------------------
cat("\n=== Final data with model outputs (first 6 rows) ===\n")
print(utils::head(clean_data))
# Show structure of the final dataset
cat("\n=== Final dataset structure ===\n")
str(clean_data)
View(clean_data, "Compositional Data")
